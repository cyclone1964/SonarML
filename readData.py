# This file contains the definition of a class for a parsed data file
# and a reader that will read the .csv files generated by the
# simulation and populate the parsed data structure
import string
import numpy as numpy

# This class defines the struture of a parsed data file used to interpret
# the .csv files generated by the simulation.
class ParsedData:
    def __init__(self):
        self.x = []
        self.y = []
        self.cycles = []
        self.frames = []
        self.dopplers = []
        self.numRows = 0
        self.numBins = 64
        self.numCycles = 0
        self.numFrames = 0
        self.numColumns = 0

# This function reads in the data file. Buried in here is the
# column/datatype equivalencey, which I spell out here for now
#
# 1 - Target/NoTarget (1/0)
# 2 - TargetDoppler (m/s)
# 3 - CycleIndex (int)
# 4 - FrameIndex (int)
# 5 - FrameRange (meters)
# 6 - PlatformSpeed (m/s)
# 7 - BeamAzimuth (degrees)
# 8 - BeamElevation (degrees)
# 9-92 - spectral values at each bin (db)
def readData(fileName):


    # Open the file get the lines and close it
    fileID = open(fileName,'r')
    lines = fileID.readlines()
    fileID.close();

    # instantiat a class of parsed data and set up the number of rows
    # and columns
    output = ParsedData()
    output.numRows = len(lines)
    fields = lines[1].split(",")
    output.numColumns = len(fields)-8

    # Initialize the all the output vectors and arrays
    output.x = numpy.zeros([output.numRows, output.numColumns])
    output.y = numpy.zeros([output.numRows])
    output.frames = numpy.zeros([output.numRows])
    output.cycles = numpy.zeros([output.numRows])
    output.dopplers = numpy.zeros([output.numRows])
    output.annotations = numpy.zeros([output.numRows,4])

    # Now parse each line. 
    for lineIndex in xrange(output.numRows):
        line = lines[lineIndex]
        fields = line.split(",")
        output.y[lineIndex] = fields[0]
        output.dopplers[lineIndex] = fields[1]
        output.cycles[lineIndex] = fields[2]
        output.frames[lineIndex] = fields[3]
        output.annotations[lineIndex,:] = fields[4:8]
        output.x[lineIndex,:] = fields[8:]

    # Now store the number of cycles and frames by finding the number of
    # unique values of their indices
    output.numCycles = len(list(set(output.cycles)))
    output.numFrames = len(list(set(output.frames)))

    return output
